#!/usr/bin/env node

/**
 * SimplePro-v3 Automated Security Penetration Testing Suite
 *
 * Tests all 4 critical security fixes from Sprint 1 Week 1:
 * 1. Hardcoded Secrets in Docker Compose
 * 2. JWT Secret Weak Fallback
 * 3. Document Sharing Password in URL
 * 4. WebSocket Connection Limit Bypass
 *
 * Usage:
 *   node scripts/security-pentest.js
 *   node scripts/security-pentest.js --category jwt
 *   node scripts/security-pentest.js --verbose
 *
 * Requirements:
 *   - API server running on http://localhost:3001
 *   - Test user credentials configured
 *   - Docker infrastructure running
 */

const http = require('http');
const https = require('https');
const fs = require('fs');
const path = require('path');
const { spawn, execSync } = require('child_process');
const WebSocket = require('ws');

// Configuration
const CONFIG = {
  apiUrl: process.env.API_URL || 'http://localhost:3001',
  wsUrl: process.env.WS_URL || 'ws://localhost:3001/realtime',
  testUsers: {
    admin: {
      username: 'admin',
      password: 'Admin123!',
    },
    user1: {
      username: 'testuser1',
      password: 'Test123!',
    },
    user2: {
      username: 'testuser2',
      password: 'Test123!',
    },
  },
  verbose: process.argv.includes('--verbose'),
  category: process.argv
    .find((arg) => arg.startsWith('--category='))
    ?.split('=')[1],
};

// Test results tracking
const results = {
  passed: 0,
  failed: 0,
  skipped: 0,
  tests: [],
  startTime: Date.now(),
};

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  bold: '\x1b[1m',
};

// Utility functions
const log = {
  info: (msg) => console.log(`${colors.blue}ℹ${colors.reset} ${msg}`),
  success: (msg) => console.log(`${colors.green}✓${colors.reset} ${msg}`),
  error: (msg) => console.log(`${colors.red}✗${colors.reset} ${msg}`),
  warning: (msg) => console.log(`${colors.yellow}⚠${colors.reset} ${msg}`),
  section: (msg) =>
    console.log(`\n${colors.bold}${colors.cyan}${msg}${colors.reset}\n`),
  verbose: (msg) =>
    CONFIG.verbose && console.log(`  ${colors.magenta}→${colors.reset} ${msg}`),
};

/**
 * Make HTTP request helper
 */
function makeRequest(options, data = null) {
  return new Promise((resolve, reject) => {
    const url = new URL(options.url || `${CONFIG.apiUrl}${options.path}`);
    const client = url.protocol === 'https:' ? https : http;

    const reqOptions = {
      hostname: url.hostname,
      port: url.port || (url.protocol === 'https:' ? 443 : 80),
      path: url.pathname + url.search,
      method: options.method || 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
    };

    if (data && typeof data === 'object') {
      data = JSON.stringify(data);
      reqOptions.headers['Content-Length'] = Buffer.byteLength(data);
    }

    const req = client.request(reqOptions, (res) => {
      let body = '';
      res.on('data', (chunk) => (body += chunk));
      res.on('end', () => {
        try {
          const response = {
            statusCode: res.statusCode,
            headers: res.headers,
            body: body,
            data: body ? JSON.parse(body) : null,
          };
          resolve(response);
        } catch (e) {
          resolve({
            statusCode: res.statusCode,
            headers: res.headers,
            body: body,
            data: null,
          });
        }
      });
    });

    req.on('error', reject);

    if (data) {
      req.write(data);
    }

    req.end();
  });
}

/**
 * Sleep helper
 */
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Record test result
 */
function recordTest(category, name, passed, details = {}) {
  const result = {
    category,
    name,
    passed,
    timestamp: new Date().toISOString(),
    ...details,
  };

  results.tests.push(result);

  if (passed) {
    results.passed++;
    log.success(`${name}`);
  } else {
    results.failed++;
    log.error(`${name}`);
  }

  if (CONFIG.verbose && details.message) {
    log.verbose(details.message);
  }

  return passed;
}

/**
 * Get authentication token
 */
async function getAuthToken(username = 'admin', password = 'Admin123!') {
  try {
    const response = await makeRequest(
      {
        path: '/api/auth/login',
        method: 'POST',
      },
      { username, password },
    );

    if (response.statusCode === 200 && response.data?.accessToken) {
      log.verbose(`Got auth token for ${username}`);
      return response.data.accessToken;
    }

    return null;
  } catch (error) {
    log.verbose(`Failed to get auth token: ${error.message}`);
    return null;
  }
}

// =============================================================================
// TEST CATEGORY 1: Hardcoded Secrets
// =============================================================================

async function testHardcodedSecrets() {
  log.section('Category 1: Hardcoded Secrets Testing');

  // Test 1.1: Search for hardcoded secrets in codebase
  try {
    log.info('Test 1.1: Scanning for hardcoded secrets...');

    const dangerousPatterns = [
      'simplepro_dev',
      'simplepro_redis',
      'simplepro_minio',
      'simplepro_dev_2024',
      'simplepro_redis_2024',
      'simplepro_minio_2024',
    ];

    let foundSecrets = false;
    const findings = [];

    for (const pattern of dangerousPatterns) {
      try {
        const result = execSync(
          `grep -r "${pattern}" . --include="*.yml" --include="*.yaml" --exclude-dir=node_modules`,
          {
            cwd: path.join(__dirname, '..'),
            encoding: 'utf8',
          },
        );

        if (result.trim()) {
          foundSecrets = true;
          findings.push({
            pattern,
            matches: result.split('\n').filter((l) => l.trim()),
          });
        }
      } catch (e) {
        // grep returns non-zero when no matches found, which is good
      }
    }

    recordTest(
      'hardcoded-secrets',
      'No hardcoded secrets in Docker Compose files',
      !foundSecrets,
      {
        message: foundSecrets
          ? `Found hardcoded secrets: ${JSON.stringify(findings, null, 2)}`
          : 'No hardcoded secrets found in codebase',
      },
    );
  } catch (error) {
    recordTest('hardcoded-secrets', 'Secret scanning', false, {
      message: `Error during scanning: ${error.message}`,
    });
  }

  // Test 1.2: Verify .env.docker.example exists
  try {
    log.info('Test 1.2: Checking for .env.docker.example...');

    const envDockerExamplePath = path.join(
      __dirname,
      '..',
      '.env.docker.example',
    );
    const exists = fs.existsSync(envDockerExamplePath);

    if (exists) {
      const content = fs.readFileSync(envDockerExamplePath, 'utf8');
      const hasGuidance =
        content.includes('Generate secure passwords') ||
        content.includes('openssl rand');

      recordTest(
        'hardcoded-secrets',
        '.env.docker.example exists with security guidance',
        hasGuidance,
        {
          message: hasGuidance
            ? 'Template file properly configured'
            : 'Missing security guidance',
        },
      );
    } else {
      recordTest('hardcoded-secrets', '.env.docker.example exists', false, {
        message: 'Template file not found',
      });
    }
  } catch (error) {
    recordTest('hardcoded-secrets', 'Environment template check', false, {
      message: error.message,
    });
  }

  // Test 1.3: Verify docker-compose uses env vars without fallbacks
  try {
    log.info('Test 1.3: Checking Docker Compose configuration...');

    const dockerComposePath = path.join(
      __dirname,
      '..',
      'docker-compose.dev.yml',
    );
    const content = fs.readFileSync(dockerComposePath, 'utf8');

    // Check for dangerous fallback patterns
    const hasFallbacks = content.match(/\$\{[^}]+:-[^}]+\}/g);

    recordTest(
      'hardcoded-secrets',
      'Docker Compose has no fallback defaults',
      !hasFallbacks,
      {
        message: hasFallbacks
          ? `Found fallback patterns: ${hasFallbacks.join(', ')}`
          : 'No fallback defaults found',
      },
    );
  } catch (error) {
    recordTest('hardcoded-secrets', 'Docker Compose configuration', false, {
      message: error.message,
    });
  }
}

// =============================================================================
// TEST CATEGORY 2: JWT Security
// =============================================================================

async function testJWTSecurity() {
  log.section('Category 2: JWT Security Testing');

  // Test 2.1: Verify weak JWT secrets are rejected (requires API restart)
  // This test checks the code, not runtime behavior
  try {
    log.info('Test 2.1: Checking JWT secret validation in code...');

    const jwtStrategyPath = path.join(
      __dirname,
      '..',
      'apps/api/src/auth/strategies/partner-jwt.strategy.ts',
    );

    if (fs.existsSync(jwtStrategyPath)) {
      const content = fs.readFileSync(jwtStrategyPath, 'utf8');

      // Check for weak fallbacks
      const hasWeakFallback =
        content.includes("|| 'default-secret-key'") ||
        content.includes("|| 'secret'") ||
        content.includes("|| ''");

      // Check for length validation
      const hasLengthValidation =
        content.includes('.length < 32') || content.includes('32 characters');

      recordTest(
        'jwt-security',
        'No weak JWT secret fallbacks in code',
        !hasWeakFallback,
        {
          message: hasWeakFallback
            ? 'Found weak fallback in code'
            : 'No weak fallbacks',
        },
      );

      recordTest(
        'jwt-security',
        'JWT secret length validation present',
        hasLengthValidation,
        {
          message: hasLengthValidation
            ? 'Length validation found'
            : 'Missing length validation',
        },
      );
    } else {
      recordTest('jwt-security', 'JWT strategy file exists', false, {
        message: 'partner-jwt.strategy.ts not found',
      });
    }
  } catch (error) {
    recordTest('jwt-security', 'JWT configuration check', false, {
      message: error.message,
    });
  }

  // Test 2.2: Attempt authentication with forged token
  try {
    log.info('Test 2.2: Testing forged JWT token rejection...');

    // Attempt 1: Token with "none" algorithm
    const noneAlgoToken =
      'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VySWQiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiJ9.';

    const response1 = await makeRequest({
      path: '/api/users/me',
      headers: { Authorization: `Bearer ${noneAlgoToken}` },
    });

    recordTest(
      'jwt-security',
      'Reject token with "none" algorithm',
      response1.statusCode === 401,
      { message: `Status: ${response1.statusCode}` },
    );

    // Attempt 2: Token with weak signature
    const weakToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJhZG1pbiJ9.WEAK_SIGNATURE';

    const response2 = await makeRequest({
      path: '/api/users/me',
      headers: { Authorization: `Bearer ${weakToken}` },
    });

    recordTest(
      'jwt-security',
      'Reject token with weak signature',
      response2.statusCode === 401,
      { message: `Status: ${response2.statusCode}` },
    );

    // Attempt 3: Malformed token
    const malformedToken = 'not.a.valid.token';

    const response3 = await makeRequest({
      path: '/api/users/me',
      headers: { Authorization: `Bearer ${malformedToken}` },
    });

    recordTest(
      'jwt-security',
      'Reject malformed token',
      response3.statusCode === 401,
      { message: `Status: ${response3.statusCode}` },
    );
  } catch (error) {
    recordTest('jwt-security', 'Token forgery test', false, {
      message: error.message,
    });
  }

  // Test 2.3: Verify proper authentication with valid token
  try {
    log.info('Test 2.3: Testing valid JWT token acceptance...');

    const token = await getAuthToken();

    if (token) {
      const response = await makeRequest({
        path: '/api/users/me',
        headers: { Authorization: `Bearer ${token}` },
      });

      recordTest(
        'jwt-security',
        'Accept valid JWT token',
        response.statusCode === 200,
        { message: `Status: ${response.statusCode}` },
      );
    } else {
      recordTest('jwt-security', 'Valid token authentication', false, {
        message: 'Could not obtain valid token',
      });
    }
  } catch (error) {
    recordTest('jwt-security', 'Valid token test', false, {
      message: error.message,
    });
  }
}

// =============================================================================
// TEST CATEGORY 3: Document Sharing Security
// =============================================================================

async function testDocumentSharing() {
  log.section('Category 3: Document Sharing Security Testing');

  // Test 3.1: Verify GET method with password is blocked
  try {
    log.info(
      'Test 3.1: Testing GET request with password in URL (should fail)...',
    );

    const response = await makeRequest({
      path: '/api/documents/shared/test-token-123/access?password=testpass',
      method: 'GET',
    });

    // Should be 404 (endpoint doesn't exist) or 405 (method not allowed)
    const blocked = response.statusCode === 404 || response.statusCode === 405;

    recordTest(
      'document-sharing',
      'GET method with password in URL is blocked',
      blocked,
      { message: `Status: ${response.statusCode}` },
    );
  } catch (error) {
    recordTest('document-sharing', 'GET method blocking', false, {
      message: error.message,
    });
  }

  // Test 3.2: Verify POST method is required
  try {
    log.info('Test 3.2: Testing POST method for document access...');

    // Note: This will fail with invalid token, but we're testing the method is accepted
    const response = await makeRequest(
      {
        path: '/api/documents/shared/test-token-123/access',
        method: 'POST',
      },
      { password: 'testpass' },
    );

    // POST method should be accepted (even if token is invalid)
    // We expect either 400 (invalid token) or 401 (wrong password), not 404/405
    const methodAccepted =
      response.statusCode !== 404 && response.statusCode !== 405;

    recordTest(
      'document-sharing',
      'POST method is accepted for document access',
      methodAccepted,
      { message: `Status: ${response.statusCode}` },
    );
  } catch (error) {
    recordTest('document-sharing', 'POST method acceptance', false, {
      message: error.message,
    });
  }

  // Test 3.3: Rate limiting test
  try {
    log.info('Test 3.3: Testing rate limiting (5 attempts per hour)...');

    const testToken = 'rate-limit-test-token';
    let rateLimitTriggered = false;
    let lastStatusCode = 0;

    // Make 6 requests rapidly
    for (let i = 1; i <= 6; i++) {
      const response = await makeRequest(
        {
          path: `/api/documents/shared/${testToken}/access`,
          method: 'POST',
        },
        { password: `wrong_password_${i}` },
      );

      lastStatusCode = response.statusCode;

      log.verbose(`Attempt ${i}: Status ${response.statusCode}`);

      if (response.statusCode === 429) {
        rateLimitTriggered = true;
        log.verbose(`Rate limit triggered on attempt ${i}`);
        break;
      }

      // Small delay between requests
      await sleep(100);
    }

    recordTest(
      'document-sharing',
      'Rate limiting blocks brute force (429 after 5 attempts)',
      rateLimitTriggered,
      {
        message: rateLimitTriggered
          ? 'Rate limiting working correctly'
          : `No rate limit after 6 attempts (last status: ${lastStatusCode})`,
      },
    );
  } catch (error) {
    recordTest('document-sharing', 'Rate limiting test', false, {
      message: error.message,
    });
  }

  // Test 3.4: Verify password not in response headers or logs
  try {
    log.info('Test 3.4: Verifying password not exposed in headers...');

    const response = await makeRequest(
      {
        path: '/api/documents/shared/test-token/access',
        method: 'POST',
      },
      { password: 'secret_password_123' },
    );

    // Check if password appears anywhere in response headers
    const headersString = JSON.stringify(response.headers).toLowerCase();
    const passwordExposed = headersString.includes(
      'secret_password_123'.toLowerCase(),
    );

    recordTest(
      'document-sharing',
      'Password not exposed in response headers',
      !passwordExposed,
      {
        message: passwordExposed
          ? 'Password found in headers!'
          : 'Password not exposed',
      },
    );
  } catch (error) {
    recordTest('document-sharing', 'Password exposure check', false, {
      message: error.message,
    });
  }
}

// =============================================================================
// TEST CATEGORY 4: WebSocket Security
// =============================================================================

async function testWebSocketSecurity() {
  log.section('Category 4: WebSocket Security Testing');

  // Test 4.1: Unauthenticated connection rejection
  try {
    log.info('Test 4.1: Testing unauthenticated WebSocket connection...');

    const ws = new WebSocket(CONFIG.wsUrl);
    let rejected = false;

    const timeout = setTimeout(() => {
      ws.close();
    }, 3000);

    await new Promise((resolve) => {
      ws.on('close', (code, reason) => {
        clearTimeout(timeout);
        rejected = code !== 1000; // 1000 = normal closure
        log.verbose(`Connection closed with code ${code}: ${reason}`);
        resolve();
      });

      ws.on('error', (error) => {
        clearTimeout(timeout);
        rejected = true;
        log.verbose(`Connection error: ${error.message}`);
        resolve();
      });

      ws.on('open', () => {
        log.verbose('Connection opened (should not happen)');
        clearTimeout(timeout);
        setTimeout(() => {
          ws.close();
          resolve();
        }, 1000);
      });
    });

    recordTest(
      'websocket-security',
      'Unauthenticated connections are rejected',
      rejected,
      {
        message: rejected
          ? 'Connection properly rejected'
          : 'Connection was accepted (FAIL)',
      },
    );
  } catch (error) {
    recordTest('websocket-security', 'Unauthenticated connection test', false, {
      message: error.message,
    });
  }

  // Test 4.2: Authenticated connection acceptance
  try {
    log.info('Test 4.2: Testing authenticated WebSocket connection...');

    const token = await getAuthToken();

    if (!token) {
      recordTest('websocket-security', 'Authenticated connection test', false, {
        message: 'Could not obtain auth token',
      });
      return;
    }

    const ws = new WebSocket(CONFIG.wsUrl, {
      headers: { Authorization: `Bearer ${token}` },
    });

    let connected = false;

    const timeout = setTimeout(() => {
      ws.close();
    }, 5000);

    await new Promise((resolve) => {
      ws.on('open', () => {
        connected = true;
        log.verbose('Authenticated connection established');
        clearTimeout(timeout);
        ws.close();
      });

      ws.on('close', () => {
        clearTimeout(timeout);
        resolve();
      });

      ws.on('error', (error) => {
        clearTimeout(timeout);
        log.verbose(`Connection error: ${error.message}`);
        resolve();
      });
    });

    recordTest(
      'websocket-security',
      'Authenticated connections are accepted',
      connected,
      { message: connected ? 'Connection successful' : 'Connection failed' },
    );
  } catch (error) {
    recordTest('websocket-security', 'Authenticated connection test', false, {
      message: error.message,
    });
  }

  // Test 4.3: Connection limit enforcement
  try {
    log.info('Test 4.3: Testing per-user connection limit (5 max)...');

    const token = await getAuthToken();

    if (!token) {
      recordTest('websocket-security', 'Connection limit test', false, {
        message: 'Could not obtain auth token',
      });
      return;
    }

    const connections = [];
    let limitEnforced = false;

    // Try to open 6 connections
    for (let i = 1; i <= 6; i++) {
      const ws = new WebSocket(CONFIG.wsUrl, {
        headers: { Authorization: `Bearer ${token}` },
      });

      const connectionResult = await new Promise((resolve) => {
        const timeout = setTimeout(() => {
          ws.close();
          resolve({ index: i, success: false, reason: 'timeout' });
        }, 3000);

        ws.on('open', () => {
          clearTimeout(timeout);
          log.verbose(`Connection ${i} established`);
          resolve({ index: i, success: true, ws });
        });

        ws.on('close', (code, reason) => {
          clearTimeout(timeout);
          if (code !== 1000) {
            log.verbose(`Connection ${i} rejected: ${reason} (code: ${code})`);
            resolve({
              index: i,
              success: false,
              reason: reason.toString(),
              code,
            });
          }
        });

        ws.on('error', (error) => {
          clearTimeout(timeout);
          log.verbose(`Connection ${i} error: ${error.message}`);
          resolve({ index: i, success: false, reason: error.message });
        });
      });

      if (connectionResult.success) {
        connections.push(connectionResult.ws);
      } else if (connectionResult.index === 6) {
        // 6th connection should be rejected
        limitEnforced = true;
      }

      await sleep(200);
    }

    // Close all connections
    connections.forEach((ws) => {
      try {
        ws.close();
      } catch (e) {
        // Ignore
      }
    });

    recordTest(
      'websocket-security',
      'Per-user connection limit enforced (5 max)',
      connections.length <= 5 && limitEnforced,
      {
        message: `Opened ${connections.length} connections, 6th rejected: ${limitEnforced}`,
      },
    );
  } catch (error) {
    recordTest('websocket-security', 'Connection limit test', false, {
      message: error.message,
    });
  }

  // Test 4.4: Event rate limiting
  try {
    log.info(
      'Test 4.4: Testing event rate limiting (100 events per minute)...',
    );

    const token = await getAuthToken();

    if (!token) {
      recordTest('websocket-security', 'Event rate limit test', false, {
        message: 'Could not obtain auth token',
      });
      return;
    }

    const ws = new WebSocket(CONFIG.wsUrl, {
      headers: { Authorization: `Bearer ${token}` },
    });

    let rateLimitTriggered = false;

    await new Promise((resolve) => {
      ws.on('open', async () => {
        log.verbose('Connection established, sending events...');

        // Send 101 events rapidly
        for (let i = 1; i <= 101; i++) {
          const event = {
            event: 'test.message',
            data: { index: i },
          };

          ws.send(JSON.stringify(event));

          // Check for rate limit response
          if (i > 100) {
            await sleep(500); // Wait for potential error response
          }
        }

        setTimeout(() => {
          ws.close();
          resolve();
        }, 2000);
      });

      ws.on('message', (data) => {
        try {
          const message = JSON.parse(data.toString());
          if (
            message.error &&
            message.error.toLowerCase().includes('rate limit')
          ) {
            rateLimitTriggered = true;
            log.verbose('Rate limit error received');
          }
        } catch (e) {
          // Ignore parse errors
        }
      });

      ws.on('close', () => resolve());
      ws.on('error', () => resolve());
    });

    recordTest(
      'websocket-security',
      'Event rate limiting prevents flooding',
      rateLimitTriggered,
      {
        message: rateLimitTriggered
          ? 'Rate limit enforced'
          : 'No rate limit detected (may need manual verification)',
      },
    );
  } catch (error) {
    recordTest('websocket-security', 'Event rate limit test', false, {
      message: error.message,
    });
  }
}

// =============================================================================
// TEST CATEGORY 5: Input Validation
// =============================================================================

async function testInputValidation() {
  log.section('Category 5: Input Validation Testing');

  const token = await getAuthToken();

  if (!token) {
    log.warning('Skipping input validation tests - no auth token');
    return;
  }

  // Test 5.1: NoSQL Injection Prevention
  try {
    log.info('Test 5.1: Testing NoSQL injection prevention...');

    const payloads = [
      { name: { $ne: null } },
      { name: { $gt: '' } },
      { email: { $where: 'this.email.length > 0' } },
      { name: { $regex: '.*' } },
    ];

    let allBlocked = true;

    for (const payload of payloads) {
      const response = await makeRequest(
        {
          path: '/api/customers/search',
          method: 'POST',
          headers: { Authorization: `Bearer ${token}` },
        },
        payload,
      );

      // Should either reject (400) or sanitize the input (200 with no results)
      if (response.statusCode === 200 && response.data?.length > 0) {
        // If it returns data, the injection might have worked
        allBlocked = false;
        log.verbose(`Payload not blocked: ${JSON.stringify(payload)}`);
      }
    }

    recordTest(
      'input-validation',
      'NoSQL injection attempts are blocked/sanitized',
      allBlocked,
      {
        message: allBlocked
          ? 'All payloads blocked'
          : 'Some payloads may have succeeded',
      },
    );
  } catch (error) {
    recordTest('input-validation', 'NoSQL injection test', false, {
      message: error.message,
    });
  }

  // Test 5.2: XSS Prevention
  try {
    log.info('Test 5.2: Testing XSS prevention...');

    const xssPayload = {
      name: '<script>alert(1)</script>',
      email: 'test@test.com',
      phone: '1234567890',
    };

    const createResponse = await makeRequest(
      {
        path: '/api/customers',
        method: 'POST',
        headers: { Authorization: `Bearer ${token}` },
      },
      xssPayload,
    );

    if (createResponse.statusCode === 201 && createResponse.data?.id) {
      // Retrieve the created customer
      const getResponse = await makeRequest({
        path: `/api/customers/${createResponse.data.id}`,
        headers: { Authorization: `Bearer ${token}` },
      });

      // Check if script tags are sanitized or escaped
      const name = getResponse.data?.name || '';
      const xssSafe =
        !name.includes('<script>') || name.includes('&lt;script&gt;');

      recordTest(
        'input-validation',
        'XSS payloads are sanitized/escaped',
        xssSafe,
        { message: xssSafe ? 'XSS prevented' : 'XSS payload not sanitized' },
      );

      // Cleanup
      await makeRequest({
        path: `/api/customers/${createResponse.data.id}`,
        method: 'DELETE',
        headers: { Authorization: `Bearer ${token}` },
      });
    } else {
      recordTest('input-validation', 'XSS prevention test', false, {
        message: 'Could not create test customer',
      });
    }
  } catch (error) {
    recordTest('input-validation', 'XSS prevention test', false, {
      message: error.message,
    });
  }
}

// =============================================================================
// Generate Test Report
// =============================================================================

function generateReport() {
  const duration = ((Date.now() - results.startTime) / 1000).toFixed(2);
  const total = results.passed + results.failed;
  const passRate = total > 0 ? ((results.passed / total) * 100).toFixed(2) : 0;

  log.section('Test Results Summary');

  console.log(`${colors.bold}Total Tests:${colors.reset} ${total}`);
  console.log(`${colors.green}Passed:${colors.reset} ${results.passed}`);
  console.log(`${colors.red}Failed:${colors.reset} ${results.failed}`);
  console.log(`${colors.blue}Pass Rate:${colors.reset} ${passRate}%`);
  console.log(`${colors.cyan}Duration:${colors.reset} ${duration}s\n`);

  // Group results by category
  const byCategory = {};
  results.tests.forEach((test) => {
    if (!byCategory[test.category]) {
      byCategory[test.category] = { passed: 0, failed: 0, tests: [] };
    }
    byCategory[test.category].tests.push(test);
    if (test.passed) {
      byCategory[test.category].passed++;
    } else {
      byCategory[test.category].failed++;
    }
  });

  console.log(`${colors.bold}Results by Category:${colors.reset}\n`);
  Object.keys(byCategory).forEach((category) => {
    const cat = byCategory[category];
    const catTotal = cat.passed + cat.failed;
    const catRate =
      catTotal > 0 ? ((cat.passed / catTotal) * 100).toFixed(0) : 0;
    const icon = catRate === 100 ? '✓' : catRate >= 50 ? '⚠' : '✗';
    const color =
      catRate === 100
        ? colors.green
        : catRate >= 50
          ? colors.yellow
          : colors.red;

    console.log(
      `  ${color}${icon}${colors.reset} ${category}: ${cat.passed}/${catTotal} (${catRate}%)`,
    );

    if (CONFIG.verbose) {
      cat.tests.forEach((test) => {
        const testIcon = test.passed
          ? `${colors.green}✓${colors.reset}`
          : `${colors.red}✗${colors.reset}`;
        console.log(`    ${testIcon} ${test.name}`);
        if (test.message) {
          console.log(
            `       ${colors.magenta}→${colors.reset} ${test.message}`,
          );
        }
      });
    }
  });

  // Save detailed report to file
  const reportPath = path.join(
    __dirname,
    '..',
    'security-pentest-results.json',
  );
  const report = {
    summary: {
      total,
      passed: results.passed,
      failed: results.failed,
      passRate: `${passRate}%`,
      duration: `${duration}s`,
      timestamp: new Date().toISOString(),
    },
    byCategory,
    tests: results.tests,
  };

  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
  console.log(
    `\n${colors.blue}ℹ${colors.reset} Detailed report saved to: ${reportPath}`,
  );

  // Exit with appropriate code
  process.exit(results.failed > 0 ? 1 : 0);
}

// =============================================================================
// Main Execution
// =============================================================================

async function main() {
  console.log(`${colors.bold}${colors.cyan}`);
  console.log('╔════════════════════════════════════════════════════════════╗');
  console.log('║   SimplePro-v3 Security Penetration Testing Suite         ║');
  console.log('║   Sprint 1 Week 1 - Security Fixes Validation             ║');
  console.log('╚════════════════════════════════════════════════════════════╝');
  console.log(colors.reset);

  try {
    // Health check
    log.info('Checking API availability...');
    const healthCheck = await makeRequest({ path: '/api/health' });

    if (healthCheck.statusCode !== 200) {
      log.error(
        "API is not responding correctly. Please ensure it's running on http://localhost:3001",
      );
      process.exit(1);
    }

    log.success('API is available');

    // Run test categories
    const categories = CONFIG.category
      ? [CONFIG.category]
      : ['secrets', 'jwt', 'documents', 'websocket', 'input'];

    for (const category of categories) {
      switch (category) {
        case 'secrets':
          await testHardcodedSecrets();
          break;
        case 'jwt':
          await testJWTSecurity();
          break;
        case 'documents':
          await testDocumentSharing();
          break;
        case 'websocket':
          await testWebSocketSecurity();
          break;
        case 'input':
          await testInputValidation();
          break;
        default:
          log.warning(`Unknown category: ${category}`);
      }
    }

    // Generate final report
    generateReport();
  } catch (error) {
    log.error(`Fatal error: ${error.message}`);
    if (CONFIG.verbose) {
      console.error(error);
    }
    process.exit(1);
  }
}

// Run tests
main();
